import random, math, csv, json
import numpy as np

# the dimension of 2D canvas
# one unit in the program presents 0.0125mm and actual size of canvas is 12.5mm * 12.5mm
unit = 0.05
width = 800
height = 800
depth = 800
active = []
pi = 3.1415926

# for the "Poisson Disk Sampling", it is in charge of generating biggest particles with radius from 190 to 95
# this part is still required to adjust manually and there are mainly two parameters to adjust, minimum distance between points and the maximum radius of circles
r = 200
k = 30
root = 2 ** 0.5
w = r / root

# 5 * 5 grid can roughly locate  minimum circles with radius which is set to be 2
# divide the whole canvan with 5 * 5 grids, because it can roughly contain a minimum circle
w1 = 5

# the maximum radius of big circles in first round of infilling is demanded to adjust, because the volume of circles in first round is so big
# if the program adds a new circle, the total volume in the sieve will go over the target so much
# but without this circle, the total volume cannot hit the target
# so setting the maximum radius of first round circles is necessary
# for next round of infilling, due to small radius, this problem does not happen


# set the range of particles' radius to make sure the process of infilling is only for one sieve
# it can make the adding particles process totally controlable
# the maximum radius of particles generated by one round can also use to controle the total mass of the sieve
# for the big particles with big mass, the problem is before total mass hitting the target, the program addes one big particles and it ends in going over the target too much
# to controle this problem, limiting the maximum radius can prevent total mass from passing the target too much
# which can make sure the distribution curve stick to the ideal one
# for the relatively small particles, this problem normally can be avoided

maximums = [95, 47, 23, 11, 5]
roundRadius = [48, 24, 12, 6, 2]

ranges = []
for maximum in maximums:
	ranges.append(maximum + maximums[0])

grid = []
Circles = []
growing = []
occupation_poisson = 0

cols = math.floor(width / w)
rows = math.floor(height / w)
depths = math.floor(depth / w)
gridnumbers = cols * rows * depths

cols1 = math.floor(width / w1)
rows1 = math.floor(height / w1)
depths1 = math.floor(depth / w1)
gridnumbers1 = cols1 * rows1 * depths1
grid1 = list(range(0, gridnumbers1))
void_grid = []
volumes = []
real_volumes = []
masses = []
differences = []
finers = []
occupation8 = 0

#users should input the parameters of the soil in the first place
target_void_ratio = 0.8
sieves = ['4.75-2.36', '2.36-1.18', '1.18-0.6', '0.6-0.3', '0.3-0.15']
soil_distributions = [1, 0.92, 0.82, 0.58, 0.14]
ideal_distributions = [0.08, 0.10, 0.24, 0.44, 0.14]
sieve_number = len(sieves)

# density of  Sand = 0.001631 g/mm³
density = 0.001631

volume = depth * width * height
ideal_totalmass = (volume / (target_void_ratio + 1))

ideal_volumes = []
ideal_masses = []
for ideal_distribution in ideal_distributions:
	ideal_volume = math.floor(ideal_totalmass * ideal_distribution)
	ideal_volumes.append(ideal_volume)
	ideal_mass = ideal_volume * density * unit ** 3
	ideal_masses.append(ideal_mass)

def main_program():
	# import_data()
	setup()
	for i in range(len(sieves)):
		fill_the_void(i, 0, 0, ideal_volumes[i], roundRadius[i], ranges[i], maximums[i])
	list_particles()
	exportdata()

def import_data():
	with open('3d-yade-round4.csv') as csvfile:
		readCSV = csv.reader(csvfile, delimiter=',')
		for row in readCSV:
			Circles.append(Circle(int(row[0]), int(row[1]), int(row[2]), int(row[3])))
		print("import data")

class Circle:
	def __init__(self, x, y, z, r):
		self.x = x
		self.y = y
		self.z = z
		self.r = r
		self.g = True
	
	def grow(self):
		if self.g is True:
			self.r = self.r + 1
	
	def edge(self):
		if ((self.x + self.r) > width) or ((self.x - self.r) < 0) or ((self.y + self.r) > height) or ((self.y - self.r) < 0) or ((self.z + self.r) > depth) or ((self.z - self.r) < 0):
			self.g = None
		return self.g

def setup():
	
	for i in range(gridnumbers):
		grid.append(None)

	#randomly select a point in the canvas
	randomx = np.random.randint(0, math.floor(cols * w))
	randomy = np.random.randint(0, math.floor(rows * w))
	randomz = np.random.randint(0, math.floor(depths * w))
	randompoint = [randomx, randomy, randomz]

	#put the point into the grid it located
	gridx = math.floor(randomx / w)
	gridy = math.floor(randomy / w)
	gridz = math.floor(randomz / w)
	grid[gridz + gridx * depths + gridy * cols * depths] = randompoint
	active.append(randompoint)
	poisson()

#generate points of Poisson Disk Sampling
def poisson():

	global occupation_poisson

	while len(active) > 0:
		check = np.random.randint(0, len(active))
		found = None
		for n in range(k):
			s = random_vector_function(r, math.floor(r * 1.5))
			sample = []
			for i in range(0, len(s)):
				sample.append(s[i] + active[check][i])

			gcol = math.floor(sample[0] / w)
			grow = math.floor(sample[1] / w)
			gdepth = math.floor(sample[2] / w)
			ggrid = gdepth + gcol * depths + grow * cols * depths

			if gcol > -1 and grow > -1 and gdepth > -1 and gcol < cols and grow < rows and gdepth < depths:
				ok = True
				#check distance between selected point and points in the around grids
				nums = [-1, 0, 1]
				num1s = [-1, 0, 1]
				num2s = [-1, 0, 1]
				for num in nums:
					for num1 in num1s:
						for num2 in num2s:
							if 0 <= gcol + num1 < cols and 0 <= grow + num < rows and 0 <= gdepth + num2 < depths:
								index = (gcol + num1) * depths + (grow + num) * cols * depths + (gdepth + num2)
								if grid[index] is None:
									pass
								else:
									d = dist(grid[index][0], grid[index][1], grid[index][2], sample[0], sample[1], sample[2])
									if d < r:
										ok = None
				if ok is True:
					found = True
					grid[gdepth + gcol * depths + grow * depths * cols] = sample
					active.append(sample)
					break
		if found is None:
			del active [check : (check + 1)]

	for i in range(len(grid)):
		if grid[i] is None:
			pass
		else:
			#delete points which are too close to the border
			if (grid[i][0] < width - 48) and (grid[i][0] > 48) and (grid[i][1] < height - 48) and (grid[i][1] > 48) and (grid[i][2] < depth - 48) and (grid[i][2] > 48):
				Circles.append(Circle(grid[i][0], grid[i][1], grid[i][2], 48))
				occupation_poisson = occupation_poisson + 1
	generateCircles_p(ranges[0], maximums[0])

	print('poisson disk sampling', occupation_poisson)

def generateCircles_p(mindis, maxi):

	for k in range(len(Circles)):
		if Circles[k].g is True:
			growing.append([Circles[k].x, Circles[k].y, Circles[k].z])

	while len(growing) > 0:
		for i in range(len(Circles)):
			if Circles[i].g is True:
				if Circles[i].r > maxi:
					Circles[i].g = None
					growing.remove([Circles[i].x, Circles[i].y, Circles[i].z])
					break
				elif Circles[i].edge() is None:
					growing.remove([Circles[i].x, Circles[i].y, Circles[i].z])
					break
				else:
					for j in range(len(Circles)):
						if (j != i) and ((Circles[i].x - mindis) < Circles[j].x < (Circles[i].x + mindis)) and ((Circles[i].y - mindis) < Circles[j].y < (Circles[i].y + mindis)) and ((Circles[i].z - mindis) < Circles[j].z < (Circles[i].z + mindis)):
							dis = dist(Circles[i].x, Circles[i].y, Circles[i].z, Circles[j].x, Circles[j].y, Circles[j].z)
							if dis < (Circles[i].r + Circles[j].r - 1):
								Circles[i].g = None
								growing.remove([Circles[i].x, Circles[i].y, Circles[i].z])
								break
			Circles[i].grow()

# remove grids which are fully covered by big spherical particles
# they will not be checked by the next round of particle insertion
def remove_grids(roundRadius):
	for i in range(len(Circles)):
		col_sub = math.floor(Circles[i].x / w1)
		row_sub = math.floor(Circles[i].y / w1)
		depth_sub = math.floor(Circles[i].z / w1)
		if Circles[i].r > w1:
			range_circles = math.ceil((Circles[i].r + 2) / w1)
			nums = list(range(-range_circles, range_circles + 1))
			num1s = list(range(-range_circles, range_circles + 1))
			num2s = list(range(-range_circles, range_circles+ 1))
			for num in nums:
				for num1 in num1s:
					for num2 in num2s:
						if 0 <= col_sub + num1 < cols1 and 0 <= row_sub + num < rows1 and 0 <= depth_sub + num2 < depths1:
							index = (col_sub + num1) * depths1 + (row_sub + num) * cols1 * depths1 + (depth_sub + num2)
							y_grid = math.floor(index / cols1 / depths1)
							x_grid = math.floor((index - y_grid * cols1 * depths1) / depths1)
							z_grid = index - x_grid * depths1 - y_grid * cols1 * depths1
							y1 = y_grid * w1
							x1 = x_grid * w1 
							z1 = z_grid * w1  
							# distances of the eight corners of the cell and the particle center
							d1 = dist(x1, y1, z1, Circles[i].x, Circles[i].y, Circles[i].z)
							d2 = dist((x1 + w1), y1, z1, Circles[i].x, Circles[i].y, Circles[i].z)
							d3 = dist(x1, (y1 + w1), z1, Circles[i].x, Circles[i].y, Circles[i].z)
							d4 = dist(x1, y1, (z1 + w1), Circles[i].x, Circles[i].y, Circles[i].z)
							d5 = dist((x1 + w1), (y1 + w1), z1, Circles[i].x, Circles[i].y, Circles[i].z)
							d6 = dist(x1, (y1 + w1), (z1 + w1), Circles[i].x, Circles[i].y, Circles[i].z)
							d7 = dist((x1 + w1), y1, (z1 + w1), Circles[i].x, Circles[i].y, Circles[i].z)
							d8 = dist((x1 + w1), (y1 + w1), (z1 + w1), Circles[i].x, Circles[i].y, Circles[i].z)
							distance_around = [d1, d2, d3, d4, d5, d6, d7, d8]
							distance_around.sort()
							distance_max = distance_around[6]
							# if the maximum distance is smaller than the particle radius plus the minimun value of the radius range for the next round
							# mark this cell as minus one
							if distance_max <= Circles[i].r + roundRadius:
								grid1[index] = -1
		else:
			# if the particle radius is smaller than the cell size, this cell will be marked as occupied directly
			index = col_sub * depths1 + row_sub * cols1 * depths1 + depth_sub
			grid1[index] = -1
	print("remove grids which are fully occupated by spheres")

def fill_the_void(roundOfInfilling, totalvolume, occupation, ideal_volume, roundRadius, rangeRadius, maximum):

	remove_grids(roundRadius)

	for i in range(gridnumbers1):
		if grid1[i] != -1:
			void_grid.append(grid1[i])
	gridnum = void_grid
	print(len(gridnum))

	# the loop will stop if the mass of this round of infilling reaches the target or it runs out of void grids
	# the size of divided grids is 5, which can normally covers all round of infilling
	while totalvolume < ideal_volume and len(gridnum) > 0:
		#randomly select a void grid and try to add particles
		q = np.random.randint(len(gridnum))
		n = radii(gridnum[q], roundRadius, rangeRadius, maximum)
		if n == 0:
			gridnum.remove(gridnum[q])
		else:
			grid1[q] = 1
			totalvolume = totalvolume + math.floor((4 / 3) * pi * n ** 3)
			occupation = occupation + 1
			gridnum.remove(gridnum[q]) 
			print(len(gridnum), totalvolume, ideal_volume)
	
	if len(gridnum) == 0:
		print('round of infilling:', roundOfInfilling, 'infilling and add:', occupation, totalvolume, ideal_volume)
		fill_the_void(roundOfInfilling, totalvolume, occupation, ideal_volume, roundRadius, rangeRadius, maximum)
	else:
		print('round of infilling:', roundOfInfilling, 'infilling and add:', occupation, totalvolume, ideal_volume)

def radii(q, initial_radius, range1, maximum1):

	global occupation1
	valid = True
	yaxis = math.floor(q / cols1 / depths1)
	xaxis = math.floor((q - yaxis * cols1 * depths1) / depths1)
	zaxis = q - xaxis * depths1 - yaxis * cols1 * depths1

	w_use = w1
	x = np.random.randint(math.floor(xaxis * w_use), math.floor((xaxis + 1) * w_use))
	y = np.random.randint(math.floor(yaxis * w_use), math.floor((yaxis + 1) * w_use))
	z = np.random.randint(math.floor(zaxis * w_use), math.floor((zaxis + 1) * w_use))

	#if the randomly selected point in the void grid is too close to borders, it will be deleted.
	m = initial_radius
	min_boundary = [x, y, z, (width - x), (height - y), (depth - z)]
	min_b = np.amin(min_boundary)
	if min_b < m:
		valid = None

    #in the reseaching sphere area with 'range1' radius
	min_around = []
	if valid is True:
		for j in range(len(Circles)):
			if ((x - range1) < Circles[j].x < (x + range1)) and ((y - range1) < Circles[j].y < (y + range1)) and ((z - range1) < Circles[j].z < (z + range1)):
				k = dist(x, y, z, Circles[j].x, Circles[j].y, Circles[j].z) - Circles[j].r
				if (k < m):
					valid = None
					break
				else:
					min_around.append(k)
			else:
				min_around.append(maximum1)

    # find the minimum distance and generate particles
	if valid is True:
		min_a = np.amin(min_around)
		if min_a <= min_b:
			if min_a <= maximum1:
				Circles.append(Circle(x, y, z, min_a))
				return min_a
			else:
				Circles.append(Circle(x, y, z, maximum1))
				return maximum1
		elif min_a > min_b:
			if min_b <= maximum1:
				Circles.append(Circle(x, y, z, min_b))
				return min_b
			else:
				Circles.append(Circle(x, y, z, maximum1))
				return maximum1
	else:
		return 0


def radius_single(q, initial_radius, range1, maximum1):

	valid = True
	yaxis = math.floor(q / cols1 / depths1)
	xaxis = math.floor((q - yaxis * cols1 * depths1) / depths1)
	zaxis = q - xaxis * depths1 - yaxis * cols1 * depths1

	w_use = w1
	x = np.random.randint(math.floor(xaxis * w_use), math.floor((xaxis + 1) * w_use))
	y = np.random.randint(math.floor(yaxis * w_use), math.floor((yaxis + 1) * w_use))
	z = np.random.randint(math.floor(zaxis * w_use), math.floor((zaxis + 1) * w_use))

	#if the randomly selected point in the void grid is too close to borders, it will be deleted.
	m = initial_radius
	min_boundary = [x, y, z, (width - x), (height - y), (depth - z)]
	min_b = np.amin(min_boundary)
	if min_b < m:
		return 0


	#in the reseaching sphere area with 'mindis' radius
	if valid is True:
		for j in range(len(Circles)):
			if ((x - range1) < Circles[j].x < (x + range1)) and ((y - range1) < Circles[j].y < (y + range1)) and ((z - range1) < Circles[j].z < (z + range1)):
				k = dist(x, y, z, Circles[j].x, Circles[j].y, Circles[j].z) - Circles[j].r
				if (k < m):
					return 0

    #generate particles:
	Circles.append(Circle(x, y, z, m))
	return m

#generate random 3D vector based on given range of magnitude
def random_vector_function(small, big):
	m = random.randrange(small, big, 1)
	angleXY = random.randrange(360)
	coordinationY = math.sin(angleXY) * m
	k = math.cos(angleXY) * m
	angleZ = random.randrange(360)
	coordinationX = round(math.cos(angleZ) * k)
	coordinationZ = round(math.sin(angleZ) * k)
	return [math.floor(coordinationX), math.floor(coordinationY), math.floor(coordinationZ)]

#calculate the distance between two points
def dist(x1, y1, z1, x2, y2, z2):
	distance = ((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2) ** 0.5
	return math.floor(distance)

#export CSV file containing positions and radius of particles
def exportdata():
	with open('position.csv', 'w', newline='') as new_file:
		csv_writer = csv.writer(new_file)
		csv_writer.writerow(['Xcoordination', 'Ycoordination', 'Zcoordination', 'radius'])
		for i in range(len(Circles)):
			csv_writer.writerow([Circles[i].x, Circles[i].y, Circles[i].z, Circles[i].r])
		print('export csv file')

def list_particles():
	global mass
	for _ in range(sieve_number):
		volumes.append(0)
		real_volumes.append(0)

	for i in range(len(Circles)):
		if Circles[i].r < 6:
			volumes[0] += (4 / 3) * pi * Circles[i].r ** 3
		elif 6 <= Circles[i].r < 12:
			volumes[1] += (4 / 3) * pi * Circles[i].r ** 3
		elif 12 <= Circles[i].r < 24:
			volumes[2] += (4 / 3) * pi * Circles[i].r ** 3
		elif 24 <= Circles[i].r < 48:
			volumes[3] += (4 / 3) * pi * Circles[i].r ** 3
		elif 48 <= Circles[i].r < 95:
			volumes[4] += (4 / 3) * pi * Circles[i].r ** 3

	totalvolume = 0
	real_totalvolume = 0
	for i in range(sieve_number):
		volumes[i] = round(volumes[i], 4)
		totalvolume += volumes[i]
		real_volumes[i] = math.floor(volumes[i]) * unit ** 3
		real_totalvolume += real_volumes[i]
	totalmass = real_totalvolume * density
	voidratio = ((width * height * depth * unit ** 3) - real_totalvolume) / real_totalvolume

	# for i in range(sieve_number):
	# 	finers.append(0)
	# 	for j in range(sieve_number):
	# 		if j <= i:
	# 			finers[i] += real_volumes[j]
	# 	finers[i] = round(finers[i] * density / totalmass, 4)
	for i in range(sieve_number):
		finers.append(0)
		for j in range(sieve_number):
			if j <= i:
				finers[i] += volumes[j]
		finers[i] = round(finers[i] / totalvolume, 4)
	finers.reverse()
	volumes.reverse()
	real_volumes.reverse()

	for volume in real_volumes:
		masses.append(volume * density)
	for i in range(len(masses)):
		differences.append(masses[i] - ideal_masses[i])
	for i in range(sieve_number):
		print('sieve:', sieves[i], 'finer:', finers[i], 'ideal volumes:', ideal_volumes[i], 'volume:', volumes[i], 'mass:', masses[i], 'ideal mass:', ideal_masses[i])
	print('void ratio:', voidratio,'totalmass:', totalmass, 'totalvolume', totalvolume)

main_program()

# , 'mass:', masses[i], 'difference:', differences[i]